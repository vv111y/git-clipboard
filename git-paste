#!/usr/bin/env python3
"""
git-paste: Apply a git-clipboard bundle into a target repo, preserving history

Two modes:
- import: create a new branch from the bundle and optionally merge/rebase
- fast-forward: add as remote and fetch, then merge selected ref(s)

Default behavior:
- If a metadata JSON is provided (or found by name), respect fields like to_subdir
- By default, create a branch `clip/<name>` with the bundle's default branch tip
- Optionally merge into current branch or a specified branch
"""

from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path


def run(cmd, cwd=None, check=True, capture_output=False, text=True):
    return subprocess.run(cmd, cwd=cwd, check=check, capture_output=capture_output, text=text)


def which(cmd: str):
    return shutil.which(cmd)


def is_git_repo(path: Path) -> bool:
    try:
        run(["git", "rev-parse", "--is-inside-work-tree"], cwd=path)
        return True
    except Exception:
        return False


def parse_args():
    p = argparse.ArgumentParser(description="Apply a git-clipboard bundle into a target repo")
    p.add_argument("bundle", nargs="?", help="Path to the .bundle file (optional: defaults to last clip)")
    p.add_argument("-m", "--meta", help="Path to the metadata JSON produced by git-cut (optional)")
    p.add_argument("-r", "--repo", default=".", help="Target repository (default: .)")
    p.add_argument("-b", "--branch", help="Branch to merge into (default: current branch)")
    p.add_argument("-a", "--as-branch", dest="as_branch", help="Name of branch to create from bundle (default: clip/<bundle-name>)")
    p.add_argument("-M", "--merge", action="store_true", help="Merge the imported branch into --branch/current")
    p.add_argument("-s", "--squash", action="store_true", help="Use a squash merge")
    p.add_argument("-R", "--rebase", action="store_true", help="Rebase the imported branch onto --branch/current before merging")
    p.add_argument("-u", "--remote-name", default=None, help="Optional remote name to add for the bundle (will be removed after)")
    p.add_argument("-F", "--no-ff", action="store_true", help="Disable fast-forward during merge")
    p.add_argument("-j", "--message", default=None, help="Custom merge commit message")
    p.add_argument("-d", "--dry-run", action="store_true", help="Preview import and potential merge/conflicts without changing the repo")
    p.add_argument("-U", "--allow-unrelated-histories", action="store_true", help="Allow merging unrelated histories (recommended for imported clips)")
    p.add_argument("-p", "--prompt-merge", action="store_true", help="After creating import branch, prompt to auto-merge if preview is clean")
    return p.parse_args()


def current_branch(repo: Path) -> str:
    out = run(["git", "rev-parse", "--abbrev-ref", "HEAD"], cwd=repo, capture_output=True)
    b = out.stdout.strip()
    if b == "HEAD":
        return "HEAD"
    return b


def has_commits(repo: Path) -> bool:
    try:
        run(["git", "rev-parse", "-q", "--verify", "HEAD"], cwd=repo)
        return True
    except Exception:
        return False


def default_as_branch_name(bundle_path: Path, meta: dict | None) -> str:
    if meta and meta.get("default_branch"):
        base = Path(bundle_path).stem
        return f"clip/{base}"
    return f"clip/{Path(bundle_path).stem}"


def read_meta(meta_path: str | None, bundle_path: Path | None = None) -> dict | None:
    candidate: Path | None = None
    if meta_path:
        candidate = Path(meta_path)
    elif bundle_path is not None:
        # try alongside the bundle with same stem
        candidate = bundle_path.with_suffix('.json')
    if candidate and candidate.exists():
        try:
            return json.loads(candidate.read_text())
        except Exception:
            return None
    return None


def main():
    args = parse_args()

    if not which("git"):
        print("Error: git is required", file=sys.stderr)
        sys.exit(1)

    # Resolve bundle path: explicit or from global clipboard pointer
    if args.bundle:
        bundle = Path(args.bundle).resolve()
    else:
        last_path = Path.home() / ".git-clipboard" / "last"
        if not last_path.exists():
            print("Error: no bundle specified and no last clip pointer found.", file=sys.stderr)
            sys.exit(1)
        try:
            last = json.loads(last_path.read_text())
            bundle = Path(last.get("bundle", "")).resolve()
            if not bundle.exists():
                print(f"Error: last bundle not found: {bundle}", file=sys.stderr)
                sys.exit(1)
        except Exception as e:
            print(f"Error reading last clip pointer: {e}", file=sys.stderr)
            sys.exit(1)
    if not bundle.exists():
        print(f"Error: bundle not found: {bundle}", file=sys.stderr)
        sys.exit(1)

    repo = Path(args.repo).resolve()
    if not is_git_repo(repo):
        print(f"Error: target is not a git repo: {repo}", file=sys.stderr)
        sys.exit(1)

    meta = read_meta(args.meta, bundle)
    as_branch = args.as_branch or default_as_branch_name(bundle, meta)

    # List heads in the bundle
    heads = run(["git", "bundle", "list-heads", str(bundle)], capture_output=True)
    lines = [line.strip() for line in heads.stdout.splitlines() if line.strip()]
    # pick first ref as tip
    refspec = None
    if lines:
        # Format: <hash> <refname>
        parts = lines[0].split()
        if len(parts) >= 2:
            refspec = parts[1]

    # Operate in a working repo: real target or a temporary clone for --dry-run
    work_repo = repo
    temp_dir = None
    remote_name = args.remote_name or f"bundle-{Path(bundle).stem}"
    if args.dry_run:
        temp_dir = Path(tempfile.mkdtemp(prefix="git-paste-dry-"))
        work_repo = temp_dir / "repo"
        run(["git", "clone", "--no-local", "--no-hardlinks", str(repo), str(work_repo)])

    # Create a branch from the bundle
    # Use a temporary remote to fetch from the bundle (git supports bundle URLs via file path)
    try:
        # Add remote pointing to bundle
        # Using 'git fetch' directly from a bundle without adding a remote is also possible; prefer remote for clarity.
        run(["git", "remote", "add", remote_name, str(bundle)], cwd=work_repo)
    except Exception:
        # Remote may already exist; try to set-url
        try:
            run(["git", "remote", "set-url", remote_name, str(bundle)], cwd=work_repo)
        except Exception:
            pass

    try:
        if refspec:
            if args.dry_run:
                # Verify fetch-ability and existence of ref in bundle without creating branch
                # Use ls-remote-like list-heads already obtained; simulate branch name
                print(json.dumps({
                    "action": "import-branch",
                    "as_branch": as_branch,
                    "source_ref": refspec,
                    "remote": remote_name,
                }, indent=2))
            else:
                run(["git", "fetch", remote_name, f"{refspec}:{as_branch}"], cwd=work_repo)
        else:
            # Fallback: fetch all heads
            if args.dry_run:
                print(json.dumps({
                    "action": "import-branch",
                    "as_branch": as_branch,
                    "source_ref": "refs/heads/*",
                    "remote": remote_name,
                }, indent=2))
            else:
                run(["git", "fetch", remote_name, f"refs/heads/*:refs/remotes/{remote_name}/*"], cwd=work_repo)
                # Pick a remote branch to base from
                out = run(["git", "branch", "-r"], cwd=work_repo, capture_output=True)
                rheads = [line.strip() for line in out.stdout.splitlines() if line.strip().startswith(f"{remote_name}/")]
                if not rheads:
                    print("Error: no heads found in bundle", file=sys.stderr)
                    sys.exit(1)
                # Create local branch from the first
                src = rheads[0]
                run(["git", "branch", as_branch, src], cwd=work_repo)

        if not args.dry_run:
            print(f"Imported branch: {as_branch}")

        # Obvious mode: if no flags at all, preview and prompt to merge if clean
        obvious_mode = (not args.merge and not args.squash and not args.rebase and not args.dry_run and not args.prompt_merge)

        # Merge if requested or in obvious mode
        if args.merge or args.squash or args.rebase or args.dry_run or obvious_mode:
            repo_has_commits = has_commits(work_repo)
            target_branch = args.branch or (current_branch(work_repo) if repo_has_commits else None)
            if not repo_has_commits:
                if args.dry_run or obvious_mode:
                    print(json.dumps({
                        "action": "merge-preview",
                        "target": None,
                        "source": as_branch,
                        "note": "Target repo has no commits; merge would effectively adopt imported branch after creation.",
                        "conflicts": False
                    }, indent=2))
                else:
                    print("Target repo has no commits; skipping merge. Imported branch created.")
                return
            if target_branch == "HEAD":
                print("Error: cannot merge onto detached HEAD. Specify --branch.", file=sys.stderr)
                sys.exit(1)
            run(["git", "rev-parse", "--verify", target_branch], cwd=work_repo)

            if not args.dry_run:
                run(["git", "checkout", target_branch], cwd=work_repo)

            if args.rebase:
                if args.dry_run or obvious_mode:
                    print(json.dumps({
                        "action": "rebase",
                        "branch": as_branch,
                        "onto": target_branch
                    }, indent=2))
                else:
                    run(["git", "rebase", target_branch, as_branch], cwd=work_repo)
                    run(["git", "checkout", target_branch], cwd=work_repo)

            merge_cmd = ["git", "merge"]
            if args.squash:
                merge_cmd.append("--squash")
            if args.no_ff:
                merge_cmd.append("--no-ff")
            if args.allow_unrelated_histories:
                merge_cmd.append("--allow-unrelated-histories")
            if args.message:
                merge_cmd += ["-m", args.message]
            merge_cmd.append(as_branch)

            if args.dry_run or obvious_mode:
                try:
                    base = run(["git", "merge-base", target_branch, as_branch], cwd=work_repo, capture_output=True).stdout.strip()
                except Exception:
                    base = ""
                conflicts = None
                if base:
                    output = run(["git", "merge-tree", base, target_branch, as_branch], cwd=work_repo, capture_output=True).stdout
                    conflicts = ("<<<<<<<" in output or ">>>>>>>" in output)
                print(json.dumps({
                    "action": "merge-preview",
                    "target": target_branch,
                    "source": as_branch,
                    "no_ff": args.no_ff,
                    "squash": args.squash,
                    "conflicts": conflicts,
                    "allow_unrelated_histories": args.allow_unrelated_histories,
                    "auto_allow_unrelated_histories": (not base),
                    "note": None if base else "Could not determine merge-base; conflict status unknown"
                }, indent=2))
                if obvious_mode and conflicts is False:
                    ans = input("Auto-merge now? [y/N]: ").strip().lower()
                    if ans not in ("y", "yes"):
                        print("Merge skipped by user.")
                        return
                    # Perform the actual merge now that user confirmed
                    # If merge-base exists, histories are related; otherwise we wouldn't be here with conflicts=False
                    run(merge_cmd, cwd=work_repo)
                    if args.squash:
                        msg = args.message or f"Squash import from {as_branch}"
                        run(["git", "commit", "-m", msg], cwd=work_repo)
                    if not args.dry_run:
                        print(f"Merged {as_branch} into {target_branch}")
                    return
                elif obvious_mode:
                    print("Conflicts likely or unknown; not auto-merging.")
                    return
            elif args.prompt_merge:
                try:
                    base = run(["git", "merge-base", target_branch, as_branch], cwd=work_repo, capture_output=True).stdout.strip()
                except Exception:
                    base = ""
                conflicts = None
                if base:
                    output = run(["git", "merge-tree", base, target_branch, as_branch], cwd=work_repo, capture_output=True).stdout
                    conflicts = ("<<<<<<<" in output or ">>>>>>>" in output)
                print(json.dumps({
                    "action": "merge-preview",
                    "target": target_branch,
                    "source": as_branch,
                    "no_ff": args.no_ff,
                    "squash": args.squash,
                    "conflicts": conflicts,
                    "allow_unrelated_histories": args.allow_unrelated_histories,
                    "note": None if base else "Could not determine merge-base; conflict status unknown"
                }, indent=2))
                if conflicts is False:
                    ans = input("Auto-merge now? [y/N]: ").strip().lower()
                    if ans not in ("y", "yes"):
                        print("Merge skipped by user.")
                        return
                else:
                    print("Conflicts likely or unknown; not auto-merging.")
                    return
            else:
                try:
                    base = run(["git", "merge-base", target_branch, as_branch], cwd=work_repo, capture_output=True).stdout.strip()
                except Exception:
                    base = ""
                if not base and "--allow-unrelated-histories" not in merge_cmd:
                    merge_cmd.insert(2, "--allow-unrelated-histories")
                run(merge_cmd, cwd=work_repo)

            if args.squash and not (args.dry_run or obvious_mode):
                msg = args.message or f"Squash import from {as_branch}"
                run(["git", "commit", "-m", msg], cwd=work_repo)

            if not args.dry_run:
                print(f"Merged {as_branch} into {target_branch}")

    finally:
        # Clean up remote if we created it implicitly (in the actual repo path)
        if args.remote_name is None and not args.dry_run:
            try:
                run(["git", "remote", "remove", remote_name], cwd=repo)
            except Exception:
                pass
        # Remove temporary clone used for dry-run
        if args.dry_run and temp_dir is not None:
            shutil.rmtree(temp_dir, ignore_errors=True)


if __name__ == "__main__":
    main()
